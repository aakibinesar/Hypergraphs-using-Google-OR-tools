# -*- coding: utf-8 -*-
"""Midterm_assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TdNj9XzlKT2Tvf9Ibj6yMoQjxMzlqXau

Maintaining Densest Subsets Efficiently in Evolving Hypergraphs - Shuguang Hu, Xiaowei Wu, T-H Hubert Chan. 

The LP-Based Exact Algorithm from Section 2 of this paper was implemented. 
The optimal values as well as the calculation of the maximum density using objective value were shown.


!pip install ortools

import ortools

from ortools.linear_solver import pywraplp
solver = pywraplp.Solver.CreateSolver('GLOP')

#data
# Here we are dealing with a hypergraph with two edges and their respective weights, e1 = 1 and e2 = 2.
# e1 contains the nodes and their respective weights 0:2, 1:5, 2:4, 3:0, 4:1 
# e2 contains the nodes and their respective weights 3:0, 4:1, 5:1, 6:3, 7:0. 

# a dense sub-hypergraph can be considered with the nodes from 0 to 5 shown in subset S

#weight of edges, e1 and e2
w_e = [1,2]

#weight of nodes, n0 to n4
w_u = [2,5,4,0,1,1,3,0]

#Subset of V or w_u 
S = [0,1,2,3,4,5]

#total node weights of the subset
w_s = 0

for i in S:
  w_s += w_u[i];

print(w_s)

"""Declare variables with lower bound O and upper bound 1 and set their names as '1/w_s' since both x and y vectors will have the same value, 1/w(s)"""

# x containing all the edges and a list of size equal to the list w_e

x = [solver.NumVar(0, 1, '1/w(s)'.format(p)) 
      for p in range(len(w_e))]

# y containing all the nodes and a list of size equal to the list w_u

y = [solver.NumVar(0, 1, '1/w(s)'.format(p)) 
      for p in range(len(w_u))]

"""Declare the objective function"""

# summation of w_e * x_e which is to be maximized

Z = solver.Sum([w_e[i] * x[i] for i in range(len(w_e))])

"""Setting up the constraints"""

#constraint: x_e <= y_u
solver.Add(x <= y)

#constraint: summation of w_u * y_u == 1
solver.Add(solver.Sum([w_u[i] * y[i] for i in range(len(w_u))]) == 1)

"""Maximizing the objective function"""

solver.Maximize(Z)

"""Number of constraints"""

print('NumConstraints:', solver.NumConstraints())

status = solver.Solve()

"""Calculate the optimal solution"""

if status == pywraplp.Solver.OPTIMAL:
  print('Solution:')
  print('Objective value =', solver.Objective().Value())
  for i in range(len(w_e)):
    print('x =', x[i].solution_value())
  for j in range(len(w_u)):
    print('y =', y[j].SolutionValue())
else:
  print('The problem does not have an optimal solution.')

"""Using the objective value and the value of w_s to calculate the maximum density. Therefore, the maximum density will be: w_e / w_s, where w_e is the total edge weight and w_s is the total node weight (|E[S]|/|S|) = maximum density"""

maximum_density = (1/w_s) * solver.Objective().Value()
print(maximum_density)